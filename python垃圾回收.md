引用计数为主，标记清楚、分代回收为辅

1. 引用计数

    引用时计数+1，不引用时计数-1，如`a = 1 		del a`，计数为0则代表垃圾，回收。

    维护一个refchain的环状双向**链表**，每创建一个对象，都会包含该对象的一些属性（c结构体），如：

    - （最基础，构造双向链表）前一个对象，下一个对象；
    - （公共）引用计数器，数据类型；
    - （不同数据类型使用不同结构体）如float是ob_fval；

2. 标记清除

    为了解决循环引用问题，另外维护一个**链表**

    - 创建特殊链表用于保存列表、元组、字典等可变序列类型，会发生循环引用问题。
    - 在某种情况下检查这个链表，查找是否存在循环引用问题，存在则计数减一。

3. 分代回收

    将标记清除分为三代，每代维护一个**链表**。

    - 0代，创建一个对象时，除了refchain计数+1，0代也+1，当对象有700个，遍历一次，如果计数不为**零**则进入1代。
    - 1代，当遍历0代10次后，遍历一次1代，计数不为**零**进入2代。
    - 2代，当遍历1代10次后，遍历一次2代。

4. 缓存

    为了避免重复创建和销毁一些对象，提高性能

    - 池（int）

        （-5，257）这个区间中对象在python初始化时就创建，并维护在一个池中，不会被销毁，计数不为0，直接从池中获取。

    - free_list（float/list/tuple/dict）

        当对象引用计数为0时，会将对象放入free_list, 当下次再创建对象时，直接拿来用，并且修改值，不再重新开辟内存空间，每个free_list链大小不一样，float-100个，list-80个，tuple-20-2000个，dict-80个。当free_list满了，则直接销毁。

        - tuple-20-2000。维护一个存放1到20个元素的列表，每个列表中可存放2000个元组对象。

