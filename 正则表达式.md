# 正则表达式

---

#### 单个字符



![1554279287530](D:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1554279287530.png)





^[0-9a-zA-Z_]{4,20}@163.com$

常用的匹配规则

| 模式     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| `\w`     | 匹配字母、数字及下划线                                       |
| `\W`     | 匹配不是字母、数字及下划线的字符                             |
| `\s`     | 匹配任意空白字符，等价于`[\t\n\r\f]`                         |
| `\S`     | 匹配任意非空字符                                             |
| `\d`     | 匹配任意数字，等价于`[0-9]`                                  |
| `\D`     | 匹配任意非数字的字符                                         |
| `\A`     | 匹配字符串开头                                               |
| `\Z`     | 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串     |
| `\z`     | 匹配字符串结尾，如果存在换行，同时还会匹配换行符             |
| `\G`     | 匹配最后匹配完成的位置                                       |
| `\n`     | 匹配一个换行符                                               |
| `\t`     | 匹配一个制表符                                               |
| `^`      | 匹配一行字符串的开头                                         |
| `$`      | 匹配一行字符串的结尾                                         |
| `.`      | 匹配任意字符，除了换行符，当`re.DOTALL`标记被指定时，则可以匹配包括换行符的任意字符 |
| `[...]`  | 用来表示一组字符，单独列出，比如`[amk]`匹配`a`、`m`或`k`     |
| `[^...]` | 不在`[]`中的字符，比如`[^abc]`匹配除了`a`、`b`、`c`之外的字符 |
| `*`      | 匹配0个或多个表达式                                          |
| `+`      | 匹配1个或多个表达式                                          |
| `?`      | 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式           |
| `{n}`    | 精确匹配`n`个前面的表达式                                    |
| `{n, m}` | 匹配`n`到`m`次由前面正则表达式定义的片段，贪婪方式           |
| `a|b`    | 匹配`a`或`b`                                                 |
| `( )`    | 匹配括号内的表达式，也表示一个组                             |



* 1.单个字符

| 字符 | 功能                             |
| ---- | :------------------------------- |
| .    | 匹配任意1个字符（除了\n）        |
| [ ]  | 匹配[ ]中列举的字符              |
| \d   | 匹配数字，即0-9                  |
| \D   | 匹配非数字，即不是数字           |
| \s   | 匹配空白，即 空格，tab键         |
| \S   | 匹配非空白                       |
| \w   | 匹配单词字符，即a-z、A-Z、0-9、_ |
| \W   | 匹配非单词字符                   |

* 2.多个字符

| *     | 匹配前一个字符出现0次或者无限次，即可有可无         |
| :---- | :-------------------------------------------------- |
| +     | 匹配前一个字符出现1次或者无限次，即至少有1次        |
| ?     | 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 |
| {m}   | 匹配前一个字符出现m次                               |
| {m,n} | 匹配前一个字符出现从m到n次                          |

* 3.开头结尾

| ^    | 匹配字符串开头 |
| ---- | :------------- |
| $    | 匹配字符串结尾 |

* 4.分组

| \|           | 匹配左右任意一个表达式           |
| ------------ | -------------------------------- |
| (ab)         | 将括号中字符作为一个分组         |
| `\num`       | 引用分组num匹配到的字符串        |
| `(?P<name>)` | 分组起别名                       |
| (?P=name)    | 引用别名为name分组匹配到的字符串 |

* 5.re的方法

match ： 从头开始匹配

search ：从任意位置开始匹配，匹配一个

findall ：从任意位置开始匹配，匹配所有

sub ： (r"" , "" , 原字符)   将匹配到的数据进行替换

split ： 根据匹配进行切割字符串，并返回一个列表

* 6.贪婪、非贪婪、r的作用

贪婪 ： "*" , "?" , "+" , "{m,n}"  匹配尽可能多的字符

非贪婪 :  "*" , "?" , "+" , "{m,n}" 后加上 ?      匹配尽可能少的字符

r的作用 :  表示原生字符串. . .     避免转义字符带来的麻烦

#### 邮箱正则

```javascript
re=/ ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$ /
re=/ ^[a-z0-9][\w\.\-]*@[a-z0-9\-]+(\.[a-z]{2,5}){1,2}$ /
   
    
自己写的
re=/^[a-zA-Z0-9]+[\.-_a-zA-Z0-9]*@[a-zA-Z0-9-_]+(\.[a-zA-Z0-9_-]{2,5})+$/
    
```



#### 正则高级

选择性区别匹配

```
(?(id/name)yes-pattern|no-pattern)
如果给定的 id 或 name 存在，将会尝试匹配 yes-pattern ，否则就尝试匹配 no-pattern，no-pattern 可选，也可以被忽略。比如， (<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$) 是一个email样式匹配，将匹配 '<user@host.com>' 或 'user@host.com' ，但不会匹配 '<user@host.com' ，也不会匹配 'user@host.com>'。
```

正向预查

``` 
(?=…)
匹配 … 的内容，但是并不消费样式的内容。这个叫做 lookahead assertion。比如， Isaac (?=Asimov) 匹配 'Isaac ' 只有在后面是 'Asimov' 的时候。

(?!…)
匹配 … 不符合的情况。这个叫 negative lookahead assertion （前视取反）。比如说， Isaac (?!Asimov) 只有后面 不 是 'Asimov' 的时候才匹配 'Isaac ' 。
```

反向预查

```
(?<=…)
匹配字符串的当前位置，它的前面匹配 … 的内容到当前位置。这叫:dfn:positive lookbehind assertion （正向后视断定）。 (?<=abc)def 会在 'abcdef' 中找到一个匹配，因为后视会往后看3个字符并检查是否包含匹配的样式。包含的匹配样式必须是定长的，意思就是 abc 或 a|b 是允许的，但是 a* 和 a{3,4} 不可以。注意以 positive lookbehind assertions 开始的样式，如 (?<=abc)def ，并不是从 a 开始搜索，而是从 d 往回看的。

(?<!…)
匹配当前位置之前不是 ... 的样式。这个叫 negative lookbehind assertion （后视断定取非）。类似正向后视断定，包含的样式匹配必须是定长的。由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。
```

